
UMyValueIdMapWrapCpp::UMyValueIdMapWrapCpp(const FObjectInitializer& ObjectInitializer) :
    m_cMap(), Super(ObjectInitializer)
{

}

void
UMyValueIdMapWrapCpp::clear()
{
    m_cMap.clear();
}

bool
UMyValueIdMapWrapCpp::insert(int32 id, int32 value)
{
    return m_cMap.insert(id, value);
}

bool
UMyValueIdMapWrapCpp::remove(int32 id, int32 value)
{
    return m_cMap.remove(id, value);

}

void
UMyValueIdMapWrapCpp::copyDeep(const UMyValueIdMapWrapCpp *other)
{
    m_cMap.copyDeep(&(other->m_cMap));
}

void
UMyValueIdMapWrapCpp::collectByValue(int32 value, int32 numReq, TArray<int32>& outIDs) const
{
    m_cMap.collectByValue(value, numReq, outIDs);
}

void
UMyValueIdMapWrapCpp::collectAll(TArray<int32>& outIDs)
{
    m_cMap.collectAll(outIDs);
}

int32
UMyValueIdMapWrapCpp::getCountByValue(int32 value) const
{
    return m_cMap.getCountByValue(value);
}


bool
UMyValueIdMapWrapCpp::contains(int32 id, int32 value)
{
    return m_cMap.contains(id, value);
}


bool
UMyValueIdMapWrapCpp::getOneIdValue(int32 &outId, int32 &outValue) const
{
    return m_cMap.getOneIdValue(outId, outValue);
}

int32
UMyValueIdMapWrapCpp::getCount() const
{
    return m_cMap.getCount();
}

void
UMyValueIdMapWrapCpp::keys(TArray<int32>& outKeys)
{
    return m_cMap.keys(outKeys);
}


/*
void UMyMJGameCoreObjFullCpp::testLocalInit()
{

    m_pIOGroupAll = MakeShareable<FMyMJGameIOGroupAllCpp>(new FMyMJGameIOGroupAllCpp());

    int32 iSeed = UMyMJUtilsLibrary::nowAsMsFromTick();
    //int32 iSeed = 11180997;
    m_pCore = MakeShareable<FMyMJGameCoreCpp>(StaticCast<FMyMJGameCoreCpp *>(new FMyMJGameCoreLocalCSCpp(MyMJGameElemWorkModeCpp::Full, iSeed)));
    m_pCore->initFullMode(m_pCore, m_pIOGroupAll.Get());

    
    FMyMJGameCmdRestartGameCpp *pCmdReset = new FMyMJGameCmdRestartGameCpp();
    pCmdReset->m_iAttendersAllRandomSelectMask = 0x0f;
    UMyMJUtilsLocalCSLibrary::genDefaultCfg(pCmdReset->m_cGameCfg);
    m_pIOGroupAll->m_aGroups[(uint8)MyMJGameRoleTypeCpp::SysKeeper].getCmdInputQueue().Enqueue(pCmdReset);

    m_pCore->tryProgress();
    //m_pCore = MakeShared<FMyMJGameCoreCpp>();
}
*/

	for (const UAttributeSet* Set : SpawnedAttributes)
	{
		if (Set)
		{
			WroteSomething |= Channel->ReplicateSubobject(const_cast<UAttributeSet*>(Set), *Bunch, *RepFlags);
		}
	}



    
void UMyMJDataSequencePerRoleCpp::trySquashBaseAndEvents(uint32 uiServerWorldTime_resolved_ms)
{
    bool bIsFull = false;
    int32 l = m_pEventsApplyingAndApplied->getCount(&bIsFull);
    if (l <= 0) {
        UE_MY_LOG(LogMyUtilsInstance, Error, TEXT("m_cEventsApplyingAndApplied have zero lenth: %d, not supposed to happen."), l);
        MY_VERIFY(false);
        return;
    }

    if (!bIsFull) {
        return;
    }

    uint32 toApplyNum = l / 2;
    MY_VERIFY(toApplyNum > 0);

    uint32 uiDeltaRecordTimeMaxCfg = MY_MJ_GAME_DATA_TIME_TO_WORLD_TIME_MS(m_uiDeltaRecordTimeMaxCfg_data_unit);
    uint32 uiTimeBase = m_cBase.getTime();

    if (uiTimeBase > uiServerWorldTime_resolved_ms) {
        UE_MY_LOG(LogMyUtilsInstance, Error, TEXT("Time screwed! %d, %d."), uiTimeBase, uiServerWorldTime_resolved_ms);
        MY_VERIFY(false);
    }

    bool bCatchUpUntilValidTimeStamp = uiTimeBase == 0;
    bool bCatchUpToTime = false;
    uint32 uiTimeCatchUpTo = uiTimeBase;

    if (!bCatchUpUntilValidTimeStamp || bForceSquash) {
        uint32 uiTimeRecorded = uiServerWorldTime_resolved_ms - uiTimeBase;
        if (uiTimeRecorded > uiDeltaRecordTimeMaxCfg || bForceSquash) {
            //we need to squash to catch up
            uiTimeCatchUpTo += uiTimeRecorded / 2;
            uiTimeCatchUpTo = MY_MJ_GAME_WORLD_TIME_MS_RESOLVE_WITH_DATA_TIME_RESOLUTION(uiTimeCatchUpTo);
            bCatchUpToTime = true;
        }
    }


    int32 iEventApplied = 0;
    if (bCatchUpUntilValidTimeStamp) {
        for (int32 i = 0; i < l; i++) {
            const FMyMJEventWithTimeStampBaseCpp& cEvent = m_pEventsApplyingAndApplied->getByIdx(i);
            uint32 uiEndTime = cEvent.getEndTime();
            if (uiEndTime > 0 && uiServerWorldTime_resolved_ms < uiEndTime) {
                //valid time stamp, and endTime not passed, yet, it is not allowed to apply yet
                break;
            }

            const FMyMJGamePusherResultCpp* pPusherResult = cEvent.getPusherResult(true);
            m_cAccessor.applyPusherResult(*pPusherResult);
            iEventApplied++;
            if (uiEndTime > 0) {
                m_cBase.setTime(uiEndTime);
                break;
            }
        }
    }
    else if (bCatchUpToTime) {
        MY_VERIFY(uiTimeCatchUpTo <= uiServerWorldTime_resolved_ms);

        for (int32 i = 0; i < l; i++) {
            const FMyMJEventWithTimeStampBaseCpp& cEvent = m_pEventsApplyingAndApplied->getByIdx(i);
            uint32 uiEndTime = cEvent.getEndTime();
            if (uiEndTime > 0 && uiTimeCatchUpTo < uiEndTime) {
                //valid time stamp, and endTime not passed, yet, it is not allowed to apply yet
                break;
            }

            const FMyMJGamePusherResultCpp* pPusherResult = cEvent.getPusherResult(true);
            m_cAccessor.applyPusherResult(*pPusherResult);
            iEventApplied++;
            if (uiEndTime > 0) {
                m_cBase.setTime(uiEndTime);
            }
        }
    }

    if (iEventApplied > 0) {
        m_pEventsApplyingAndApplied->removeByIdx(0, iEventApplied);
        UE_MY_LOG(LogMyUtilsInstance, Display, TEXT("Squashed Data Sequence: bCatchUpUntilValidTimeStamp %d, bCatchUpToTime %d, %d -> %d."), bCatchUpUntilValidTimeStamp, bCatchUpToTime, l, m_pEventsApplyingAndApplied->getCount());
    }

    MY_VERIFY(m_cBase.getTime() > 0);
};