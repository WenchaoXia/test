// Fill out your copyright notice in the Description page of Project Settings.

#include "MyMJGamePusher.h"
#include "MyMJGameCore.h"

void
FMyMJGamePusherPointersCpp::copyDeepWithRoleType(const FMyMJGamePusherPointersCpp *pOther, MyMJGameRoleTypeCpp eRoleType)
{
    clear();

    int32 l = pOther->m_aPushers.Num();;
    //MY_VERIFY(l > 0);

    for (int i = 0; i < l; i++) {
        FMyMJGamePusherBaseCpp *pNewRaw = pOther->m_aPushers[i]->cloneDeepWithRoleType(eRoleType);
        if (pNewRaw) {
            this->m_aPushers.Emplace(pNewRaw);
        }
        //TSharedPtr<FMyMJGamePusherBaseCpp> pNew = MakeShared<>
    }

    l = pOther->m_aPushersSharedPtr.Num();;
    //MY_VERIFY(l > 0);
    for (int i = 0; i < l; i++) {
        FMyMJGamePusherBaseCpp *pNewRaw = pOther->m_aPushersSharedPtr[i]->cloneDeepWithRoleType(eRoleType);
        if (pNewRaw) {
            this->m_aPushersSharedPtr.Emplace(pNewRaw);
        }
        //TSharedPtr<FMyMJGamePusherBaseCpp> pNew = MakeShared<>
    }

    MY_VERIFY(getCount() > 0);
}

FMyMJGamePusherBaseCpp*
FMyMJGamePusherFillInActionChoicesCpp::cloneDeepWithRoleType(MyMJGameRoleTypeCpp eRoleType) const
{
    //First, attender only knows himself's choices
    FMyMJGamePusherFillInActionChoicesCpp *pRet = NULL;
    if (eRoleType == MyMJGameRoleTypeCpp::SysKeeper) {
        pRet = new FMyMJGamePusherFillInActionChoicesCpp();
    }
    else if ((uint8)eRoleType < 4) {
        if (m_iIdxAttender == (uint8)eRoleType) {
            pRet = new FMyMJGamePusherFillInActionChoicesCpp();
        }
    }

    if (pRet) {
        pRet->m_cActionChoices.copyDeepWithRoleType(&m_cActionChoices, MyMJGameRoleTypeCpp::SysKeeper); //If datastream contains choice info(attender matches), always keep max info
        pRet->m_iActionGroupId = m_iActionGroupId;
        pRet->m_iIdxAttender = m_iIdxAttender;
    }

    return pRet;
}

FMyMJGamePusherBaseCpp*
FMyMJGamePusherMadeChoiceNotifyCpp::cloneDeepWithRoleType(MyMJGameRoleTypeCpp eRoleType) const
{
    FMyMJGamePusherMadeChoiceNotifyCpp *pRet = NULL;
    if (eRoleType == MyMJGameRoleTypeCpp::SysKeeper) {
        pRet = new FMyMJGamePusherMadeChoiceNotifyCpp();
    }
    else if ((uint8)eRoleType < 4) {
        if (m_iIdxAttender == (uint8)eRoleType) {
            pRet = new FMyMJGamePusherMadeChoiceNotifyCpp();
        }
    }

    if (pRet) {
        *pRet = *this;
    }

    return pRet;
}

FMyMJGamePusherBaseCpp* 
FMyMJGamePusherResetGameCpp::cloneDeepWithRoleType(MyMJGameRoleTypeCpp eRoleType) const
{
    FMyMJGamePusherResetGameCpp *pRet = new FMyMJGamePusherResetGameCpp();
    *pRet = *this;

    if (eRoleType != MyMJGameRoleTypeCpp::SysKeeper) {
        int l = pRet->m_aShuffledValues.Num();
        for (int i = 0; i < l; i++) {
            pRet->m_aShuffledValues[i] = 0; //0 means unknown
        }
    }

    //UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("FMyMJGamePusherResetGameCpp clones with roleType %d"), (uint8)eRoleType);

    return pRet;
}

void
FMyMJGamePusherResetGameCpp::init(FRandomStream *pRandomStream, FMyMJGameCfgCpp &cGameCfg, FMyMJGameRunDataCpp &cGameRunData, int32 iAttenderBehaviorRandomSelectMask)
{

    m_cGameCfg = cGameCfg;
    m_cGameRunData = cGameRunData;
    m_iAttenderBehaviorRandomSelectMask = iAttenderBehaviorRandomSelectMask;

    TArray<int32> &outValues = m_aShuffledValues;
    outValues.Reset(160);


    bool bHaveWordCards = m_cGameCfg.m_cCardPackCfg.m_bHaveWordCards;
    bool bHaveHuaCards = m_cGameCfg.m_cCardPackCfg.m_bHaveHuaCards;
    bool bHaveZhong = m_cGameCfg.m_cCardPackCfg.m_bHaveZhongCards;

    int32 idx;
    int32 cardValue;

    for (int32 i = 0; i < 3; i++) {
        for (int32 j = 1; j < 10; j++) {
            cardValue = i * 10 + j;

            for (int32 k = 0; k < 4; k++) {
                idx = outValues.Emplace();
                outValues[idx] = cardValue;
            }
        }
    }

    if (bHaveWordCards) {
        for (cardValue = 31; cardValue < 35; cardValue++) {

            for (int32 k = 0; k < 4; k++) {
                idx = outValues.Emplace();
                outValues[idx] = cardValue;
            }

        }

        for (cardValue = 41; cardValue < 44; cardValue++) {

            for (int32 k = 0; k < 4; k++) {
                idx = outValues.Emplace();
                outValues[idx] = cardValue;
            }

        }
    }

    if (bHaveHuaCards) {
        for (cardValue = 51; cardValue < 59; cardValue++) {

            idx = outValues.Emplace();
            outValues[idx] = cardValue;
        }
    }

    if (bHaveZhong && !bHaveWordCards) {
        cardValue = 41;
        for (int32 k = 0; k < 4; k++) {
            idx = outValues.Emplace();
            outValues[idx] = cardValue;
        }
    }

    //let's shuffle
    int32 remainingCards = outValues.Num();

    while (remainingCards > 2) {
        int32 idxPicked = pRandomStream->RandRange(0, remainingCards - 2);
        int32 &pickedCardValue = outValues[idxPicked];
        int32 tempCardValue = pickedCardValue;
        outValues[idxPicked] = outValues[remainingCards - 1];
        outValues[remainingCards - 1] = tempCardValue;

        remainingCards--;
    }

}

FMyMJGamePusherBaseCpp*
FMyMJGameActionThrowDicesCpp::cloneDeepWithRoleType(MyMJGameRoleTypeCpp eRoleType) const
{
    FMyMJGameActionThrowDicesCpp *pRet = NULL;
    pRet = new FMyMJGameActionThrowDicesCpp();

    *pRet = *this;

    return pRet;
}

void FMyMJGameActionThrowDicesCpp::init(MyMJGameActionThrowDicesSubTypeCpp eSubType, int32 idxAttender, FRandomStream *pRandomStream)
{
    m_eSubType = eSubType;
    m_iIdxAttender = idxAttender;
    m_iDiceNumber0 = pRandomStream->RandRange(1, 6);
    m_iDiceNumber1 = pRandomStream->RandRange(1, 6);
}

void FMyMJGameActionThrowDicesCpp::getDiceNumbers(int32 &outDiceNumber0, int32 &outDiceNumber1) const
{
    MY_VERIFY(m_iDiceNumber0 >= 1 && m_iDiceNumber0 < 7);
    MY_VERIFY(m_iDiceNumber1 >= 1 && m_iDiceNumber1 < 7);

    outDiceNumber0 = m_iDiceNumber0;
    outDiceNumber1 = m_iDiceNumber1;
}

MyMJGameActionThrowDicesSubTypeCpp FMyMJGameActionThrowDicesCpp::getSubType() const
{
    return m_eSubType;
}

FMyMJGamePusherBaseCpp*
FMyMJGameActionDistCardAtStartCpp::cloneDeepWithRoleType(MyMJGameRoleTypeCpp eRoleType) const
{
    FMyMJGameActionDistCardAtStartCpp *pRet = NULL;
    pRet = new FMyMJGameActionDistCardAtStartCpp();

    *pRet = *this;

    if (eRoleType == MyMJGameRoleTypeCpp::SysKeeper) {

    }
    else if ((uint8)eRoleType < 4 && m_iIdxAttender == (uint8)eRoleType) {
        //himself's data
    }
    else {
        //erase the value data
        int32 l = pRet->m_aIdValues.Num();
        for (int32 i = 0; i < l; i++) {
            pRet->m_aIdValues[i].m_iValue = 0;
        }
    }

    return pRet;
}

int32 FMyMJGameActionGiveOutCardsCpp::makeSubSelection(TArray<int32> &subSelections)
{


    if (m_bRestrict2SelectCardsJustTaken) {
        return -4;
    }
    else {
        if (subSelections.Num() != 1) {
            return -1;
        }

        int32 selectedId = subSelections[0];
        if (selectedId < 0) {
            return -2;
        }

        if (m_aOptionIdsHandCard.Find(selectedId) == INDEX_NONE && m_aOptionIdsJustTaken.Find(selectedId) == INDEX_NONE) {
            return -3;
        }

        m_aIdValuePairsSelected.Reset();
        int32 idx = m_aIdValuePairsSelected.Emplace();
        m_aIdValuePairsSelected[idx].m_iId = selectedId;
    }

    return 0;
};

int32 FMyMJGameActionGiveOutCardsCpp::genRandomSubSelections(FRandomStream *pRandomStream, TArray<int32> &outSubSelections)
{
    outSubSelections.Reset();
    if (m_bRestrict2SelectCardsJustTaken) {
        MY_VERIFY(false);
        return -10;
    }
    else {


        int32 c = getRealCountOfSelection();
        if (c < 1) {
            return -1;
        }

        int32 count0 = m_aOptionIdsHandCard.Num();
        int32 count1 = m_aOptionIdsJustTaken.Num();

        int32 retSelectedId;
        int32 randNo = pRandomStream->RandRange(0, c - 1);
        if (randNo < count0) {
            retSelectedId = m_aOptionIdsHandCard[randNo];
        }
        else {
            MY_VERIFY(count1 > 0);
            int idx = randNo - count0;
            MY_VERIFY(idx < count1);
            retSelectedId = m_aOptionIdsJustTaken[idx];
        }

        outSubSelections.Emplace(retSelectedId);

        return 0;
    }
}

void FMyMJGameActionGiveOutCardsCpp::resolveActionResult(FMyMJGameAttenderCpp &attender)
{
    MY_VERIFY(m_aIdValuePairsSelected.Num() > 0);

    attender.getpCore()->getpCardPack()->helperResolveValues(m_aIdValuePairsSelected);
}

void FMyMJGameActionHuCpp::resolveActionResult(FMyMJGameAttenderCpp &attender)
{
    m_aRevealingCards.Reset();

    FMyMJCardPackCpp *pCardPack = attender.getpCore()->getpCardPack();
    int32 l = pCardPack->getLength();
    for (int32 i = 0; i < l; i++) {
        FMyMJCardCpp *pCard = pCardPack->getCardByIdx(i);
        if (pCard->m_eFlipState == MyMJCardFlipStateCpp::Up) {
            //already revealed
            continue;
        }

        int32 idx = m_aRevealingCards.Emplace();
        m_aRevealingCards[idx].m_iId = pCard->m_iId;
        pCardPack->helperResolveValue(m_aRevealingCards[idx]);

    }

}


void
UMyMJGameUtilsLibrary::testArrayPointerSerialize(AMyTestParentClass0 *pInParent, AMyTestChildClass0 *pInChild, AMyTestParentClass0 *pOutParent, int32 param)
{
    TSharedPtr<FMyMJGameActionBaseCpp> pChild = MakeShareable<FMyMJGameActionBaseCpp>(new FMyMJGameActionBaseCpp());
    pChild->getIdxAttenderRef() = 5;
    //TArray<FMyMJGamePusherBaseCpp> m_aPushers;

    //ToBinary << a;

    TSharedPtr<FMyMJGamePusherBaseCpp> pParent = MakeShareable<FMyMJGamePusherBaseCpp>(new FMyMJGamePusherBaseCpp());

    FBufferArchive ToBinary;
    FMemoryReader FromBinary = FMemoryReader(ToBinary);

    FMyMJGamePusherBaseCpp *pInst;
    
    
    pInst = pChild.Get();

    //UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("toBin: %d, %s"), (uint8)pInst->m_eType, *(pInst->StaticStruct()->GetClass()->GetFullName()));
    UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("toBin: %d, %s"), (uint8)pInst->getType(), *(pInst->StaticStruct()->GetStructCPPName()));
    ToBinary.Seek(0);
    pInst->StaticStruct()->SerializeBin(ToBinary, pInst);


    TSharedPtr<FMyMJGamePusherBaseCpp> pReverted = MakeShareable<FMyMJGamePusherBaseCpp>(new FMyMJGamePusherBaseCpp());
    pInst = pReverted.Get();

    FromBinary.Seek(0);
    pInst->StaticStruct()->SerializeBin(FromBinary, pInst);
    //UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("FromBin: %d, %s"), (uint8)pInst->m_eType, *(pInst->StaticStruct()->GetClass()->GetFullName()));
    UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("FromBin: %d, %s"), (uint8)pInst->getType(), *(pInst->StaticStruct()->GetStructCPPName()));
    
    /*
    AMyTestParentClass0 *pBase;


    pInParent->m_iTest = 2;
    pInChild->m_iTest = 5;
    pInChild->m_iTestChild = 10;

    pBase = pInChild;

    FBufferArchive ToBinary2;
    FMemoryReader FromBinary2 = FMemoryReader(ToBinary2);

    ToBinary2.Seek(0);
    pBase->SerializeScriptProperties(ToBinary2);
    UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("ToBin2: %d, %s"), pBase->m_iTest, *(pBase->GetClass()->GetFullName()));

    pBase = pOutParent;
    FromBinary2.Seek(0);
    pBase->Serialize(FromBinary2);
    UE_MY_LOG(LogMyUtilsInstance, Warning, TEXT("FromBin2: %d, %s"), pBase->m_iTest, *(pBase->GetClass()->GetFullName()));
    */
    //ToBinary << p;
}