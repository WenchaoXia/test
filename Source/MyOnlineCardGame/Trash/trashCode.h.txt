
/**
*
*/
UCLASS(BlueprintType, Blueprintable, meta = (ShortTooltip = "An value-idArray map, commonly used in card game."))
class MYONLINECARDGAME_API UMyValueIdMapWrapCpp : public UObject
{
    //GENERATED_BODY()
    GENERATED_UCLASS_BODY()

public:
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    void clear();

    /**
    * @return false if duplicated one found
    */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    bool insert(int32 id, int32 value);

    /*
     * @return false if not found
     */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    bool remove(int32 id, int32 value);

    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    void copyDeep(const UMyValueIdMapWrapCpp *other);

    /*
    * collect IDs by value, order is not guareenteed
    * @param numReq	num to collect, if <= 0, collect every thing
    */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    void collectByValue(int32 value, int32 numReq, TArray<int32>& outIDs) const;

    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    void collectAll(TArray<int32>& outIDs);

    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    int32 getCountByValue(int32 value) const;

    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    bool contains(int32 id, int32 value);

    /*
    * try find one elem, return false if not found
    */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    bool getOneIdValue(int32 &outId, int32 &outValue) const;

    /**
    * return the elem count
    * @return the count in map
    */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    int32 getCount() const;

    /*
    * return the keys of map, correspond the the "value" part of insert API
    * @param outKeys the keys
    */
    UFUNCTION(BlueprintCallable, Category = "MyValueIdMapCpp")
    void keys(TArray<int32>& outKeys);


protected:

    FMyValueIdMapCpp m_cMap;
};


/*
USTRUCT(BlueprintType)
struct FMyMJHuCardTypeCfgCpp
{
    GENERATED_USTRUCT_BODY()

    FMyMJHuCardTypeCfgCpp()
    {
        m_eType = MyMJHuCardTypeCpp::Invalid;

        m_iScoreDirectPay = 0;
        m_bContinueGame = false;
    };

    //UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Actor Hidden In Game", SequencerTrackClass = "MovieSceneVisibilityTrack"))
    //UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly="true", HideSelfPin="true", HidePin="InputAxisName"))
    //UFUNCTION(BlueprintCallable, meta=(BlueprintProtected = "true"), Category="Game")
    
    // the card combination type
    UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Type"))
    MyMJHuCardTypeCpp m_eType;

    // the priority when checking hu, let's write it dead in code
    //UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Priority"))
    //int32 m_iPriority;

    // if hu, the score sure to win per attender, even when game end the attender didn't hu, used in some local MJ 
    UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Score Direct Pay"))
    int32 m_iScoreDirectPay;

    // if true, when hu with it, continue game instead of end game
    UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Continue Game"))
    bool m_bContinueGame;
};
*/


    /* whether menqing is required for ZuHeLong */
    UPROPERTY(BlueprintReadWrite, meta = (DisplayName = "Req MenQing for ZuHeLong"))
    bool m_bReqMenQingForZuHeLong;
    ¡¢


    
/*
UCLASS(BlueprintType, Blueprintable)
class MYONLINECARDGAME_API UMyMJGameCoreObjCpp : public UObject
{
    GENERATED_BODY()

public:


};


UCLASS(BlueprintType, Blueprintable)
class MYONLINECARDGAME_API UMyMJGameCoreObjFullCpp : public UMyMJGameCoreObjCpp
{
    GENERATED_BODY()

public:

    void pushCmd(const FMyMJGameCmdBaseCpp *pIn);
    FMyMJGameCmdBaseCpp* pullCmdResp();

    UFUNCTION(BlueprintCallable, Category = "UMyMJGameCoreObjFullCpp")
    void testLocalInit();


    TSharedPtr<FMyMJGameCoreCpp> m_pCore;
    TSharedPtr<FMyMJGameIOGroupAllCpp> m_pIOGroupAll;

    //return whether mode is changed to target type
    bool tryChangeMode(MyMJGameRuleTypeCpp eRuleType);

    TSharedPtr<FMyMJGameCoreThreadControlCpp> m_pCoreFullWithThread;

};
*/


USTRUCT(BlueprintType)
struct FMyMJGamePusherPointersCpp
{
    GENERATED_USTRUCT_BODY()

    bool Serialize(FArchive& Ar);
    bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);
    bool NetDeltaSerialize(FNetDeltaSerializeInfo & DeltaParms);

}

template<>
struct TStructOpsTypeTraits<FMyMJGamePusherPointersCpp> : public TStructOpsTypeTraitsBase2<FMyMJGamePusherPointersCpp>
{
    enum
    {

        WithSerializer = true,
        WithNetSerializer = true,
        //WithNetDeltaSerializer = true,  //If true, none of serialize funtion got called during RPC
    };
};


UCLASS(BlueprintType, Blueprintable)
class MYONLINECARDGAME_API AMyTestActorBaseCpp : public AActor
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, Client, unreliable)
    void testRPCWithPusherPointers(const FMyMJGamePusherPointersCpp &pusherPointers);
}



 void clear()
    {
        m_aEvents.Reset();
        m_uiLastEventEndTime_data_unit = 0;
    };

    inline
        int32 getCount() const
    {
        return m_aEvents.Num();
    };

    const FMyMJEventWithTimeStampBaseCpp& getByIdx(int32 idx) const
    {
        MY_VERIFY(idx >= 0 && idx < getCount());
        return m_aEvents[idx];
    };

    const FMyMJEventWithTimeStampBaseCpp* getLast() const
    {
        if (getCount() > 0) {
            return &m_aEvents.Top();
        }
        else {
            return NULL;
        }
    };

    void removeByIdx(int32 idx, int32 count)
    {
        MY_VERIFY(idx >= 0);
        MY_VERIFY((idx + count) <= getCount());
        m_aEvents.RemoveAt(idx, count);
    };

    //only event that have duration records time, otherwise consdier them should be applied instantly
    //all calc here must be resolved to resolution
    FMyMJEventWithTimeStampBaseCpp& insert(uint32 uiTimeStamp_resolved_ms, uint32 uiDur_resolved_ms, bool bForceRecordTime)
    {
        MY_VERIFY(MY_MJ_GAME_WORLD_TIME_MS_IS_RESOLVED(uiTimeStamp_resolved_ms));
        MY_VERIFY(MY_MJ_GAME_WORLD_TIME_MS_IS_RESOLVED(uiDur_resolved_ms));

        int32 idx = m_aEvents.Emplace();
        FMyMJEventWithTimeStampBaseCpp& ret = m_aEvents[idx];

        if (bForceRecordTime) {
            ret.setStartTime(uiTimeStamp_resolved_ms);
            setLastEventEndTime(uiTimeStamp_resolved_ms);
        }

        if (uiDur_resolved_ms > 0) {
            ret.setStartTime(uiTimeStamp_resolved_ms);
            ret.setDuration(uiDur_resolved_ms);
            //m_uiLastEventEndTime_10ms = uiTimeStamp_10ms + uiDur_10ms;

            setLastEventEndTime(uiTimeStamp_resolved_ms + uiDur_resolved_ms);

        }
        else {
        }


        return ret;
    };

    void setLastEventEndTime(uint32 uiTimeStamp_resolved_ms)
    {
        MY_VERIFY(MY_MJ_GAME_WORLD_TIME_MS_IS_RESOLVED(uiTimeStamp_resolved_ms));
        m_uiLastEventEndTime_data_unit = MY_MJ_GAME_WORLD_TIME_MS_TO_DATA_TIME(uiTimeStamp_resolved_ms);
    }

    //unit is ms, resolved
    uint32 getLastEventEndTime() const
    {
        return MY_MJ_GAME_DATA_TIME_TO_WORLD_TIME_MS(m_uiLastEventEndTime_data_unit);
    };

        UPROPERTY()
    uint32 m_uiLastEventEndTime_data_unit;