// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"

//#include "Core.h"
#include "CoreUObject.h"

#include "UObject/Object.h"
#include "UObject/NoExportTypes.h"

#include "Utils/MyMJUtils.h"
#include "MyMJCardPack.h"

#include "MyMJCommonDefines.h"

#include "GameFramework/Actor.h"

#include "MyMJGamePusher.generated.h"

//typedef struct FMyMJGamePusherPointersCpp FMyMJGamePusherPointersCpp;

//Every thing here need to be serialized

UENUM(BlueprintType)
enum class MyMJGameStateUpdateReasonCpp : uint8
{
    Invalid = 0                             UMETA(DisplayName = "Invalid"),
    NoCardLeft = 10                         UMETA(DisplayName = "NoCardLeft"),
    AttenderHu = 15                         UMETA(DisplayName = "AttenderHu"),
    DismissedByCmd = 50                     UMETA(DisplayName = "DismissedByCmd"),
};

UENUM(BlueprintType)
enum class MyMJGamePusherTypeCpp : uint8
{
    Invalid = 0                         UMETA(DisplayName = "Invalid"),
    PusherBase = 10                     UMETA(DisplayName = "PusherBase"),
    PusherFillInActionChoices = 11      UMETA(DisplayName = "PusherFillInActionChoices"),
    PusherMadeChoiceNotify = 12         UMETA(DisplayName = "PusherMadeChoiceNotify"),
    PusherCountUpdate = 13              UMETA(DisplayName = "PusherCountUpdate"),
    PusherResetGame = 20                UMETA(DisplayName = "PusherResetGame"),
    PusherUpdateCards = 25              UMETA(DisplayName = "PusherUpdateCards"), //mostly used in game end, reveal all card values
    PusherUpdateTing = 30               UMETA(DisplayName = "PusherUpdateTing"),

    ActionBase = 50                     UMETA(DisplayName = "ActionBase"),
    ActionStateUpdate = 51              UMETA(DisplayName = "ActionStateUpdate"),
    ActionNoAct = 60                    UMETA(DisplayName = "ActionNoAct"),
    ActionThrowDices = 71               UMETA(DisplayName = "ActionThrowDices"),
    ActionDistCardsAtStart = 72         UMETA(DisplayName = "ActionDistCardsAtStart"),

    ActionTakeCards = 75                UMETA(DisplayName = "ActionTakeCards"), //May take card normal, or buzhang, or gang
    ActionGiveOutCards = 76             UMETA(DisplayName = "ActionGiveOutCards"),
    ActionWeave = 80                    UMETA(DisplayName = "ActionWeave"),

    ActionHu = 90                       UMETA(DisplayName = "ActionHu"),

    ActionHuBornLocalCS = 150           UMETA(DisplayName = "ActionHuBornLocalCS"),
    ActionZhaNiaoLocalCS = 151          UMETA(DisplayName = "ActionZhaNiaoLocalCS"),

};

#define PriMyMJGameActionStateUpdate 200
#define PriMyMJGameActionNoAct 100
#define PriMyMJGameActionThrowDice 100
#define PriMyMJGameActionDistCardAtStart 100
#define PriMyMJGameActionTakeCards 100
#define PriMyMJGameActionGiveOutCards 100
#define PriMyMJGameActionWeaveShunZiMing 1500
#define PriMyMJGameActionWeaveKeZiMing 1600
#define PriMyMJGameActionWeaveGangMing 1700
#define PriMyMJGameActionWeaveGangAn   1750

#define PriMyMJGameActionHu 2000

#define PriMyMJGameActionHuBornLocalCS  100
#define PriMyMJGameActionZhaNiaoLocalCS 100

USTRUCT(BlueprintType)
struct FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherBaseCpp()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherBase;
    };

    virtual ~FMyMJGamePusherBaseCpp()
    {};

    //Never call this directly, since UE4 struct forbid pure virtual function, let's use fake function here to test it at runtime
    //return new one alloceted on heap and neccessary transform have done on it, or NULL to tip this role doesn't need to store it
    virtual FMyMJGamePusherBaseCpp* cloneDeep() const
    {
        MY_VERIFY(false);
        return NULL;
    };

    virtual FString genDebugString() const
    {
        //const UEnum* enumPtr = FindObject<UEnum>(ANY_PACKAGE, *Name, true);
        /*
        const UEnum* enumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("MyMJGamePusherTypeCpp"), true);
        if (!enumPtr)
        {
            return FString("Invalid. ");
        }

        return enumPtr->GetEnumNameStringByValue((uint8)m_eType) + ". ";
        */

        return UMyMJUtilsLibrary::getStringFromEnum(TEXT("MyMJGamePusherTypeCpp"), (uint8)m_eType) +TEXT(". ");
    };

    inline
    MyMJGamePusherTypeCpp getType()
    {
        return m_eType;
    };

protected:

    UPROPERTY()
    MyMJGamePusherTypeCpp m_eType;
};

//A custom struct which we will implement serialize (default UE4 did not support TArray<struct *>)
//FIFO,like a queue, can transfer over thread, but never used it by multiple thread at one time
USTRUCT(BlueprintType)
struct FMyMJGamePusherPointersCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherPointersCpp()
    {
    };

    virtual ~FMyMJGamePusherPointersCpp()
    {
        clear();
    };

    //Copy everything, this make it safe whenm another thread consume it
    void copyDeepWithRoleType(const FMyMJGamePusherPointersCpp *pOther, MyMJGameRoleTypeCpp eRoleType);

    FMyMJGamePusherPointersCpp& operator = (const FMyMJGamePusherPointersCpp& rhs)
    {
        if (this == &rhs) {
        return *this;
        }

        copyDeepWithRoleType(&rhs, MyMJGameRoleTypeCpp::SysKeeper);
        return *this;
    };

    void clear()
    {
        if (m_aPushersSharedPtr.Num() <= 0) {
            //not managed by SharedPtr
            int32 l = m_aPushers.Num();
            for (int32 i = 0; i < l; i++) {
                delete(m_aPushers[i]);
                m_aPushers[i] = NULL;
            }
        }

        m_aPushers.Empty();
        m_aPushersSharedPtr.Empty();
    };

    void prepareForConsume()
    {
        if (m_aPushers.Num() > 0 && m_aPushersSharedPtr.Num() <= 0) {
            int32 l = m_aPushers.Num();
            for (int32 i = 0; i < l; i++) {
                m_aPushersSharedPtr.Emplace(m_aPushers[i]);
            }

            m_aPushers.Empty();
        }
    };

    //@pPusher must be created on heap, and its ownership will be transfered to this, can only be called on producer thread if consumer thread != producer thread
    //Can only be called before consume
    void give(FMyMJGamePusherBaseCpp *pPusher)
    {
        MY_VERIFY(m_aPushersSharedPtr.Num() <= 0);
        m_aPushers.Emplace(pPusher);
    };

    //can only be called on consumer thread if consumer thread != producer thread, otherwise random crash
    TSharedPtr<FMyMJGamePusherBaseCpp> getSharedPtrAt(int32 idx)
    {
        prepareForConsume();

        MY_VERIFY(idx >= 0 && idx < m_aPushersSharedPtr.Num());

        return m_aPushersSharedPtr[idx];
    };

    /*
    FMyMJGamePusherBaseCpp* take()
    {
        FMyMJGamePusherBaseCpp *pRet = NULL;
        if (m_aPushers.Num() > 0) {
            pRet = m_aPushers[0];
            m_aPushers.RemoveAt(0);
        }
        else {

        }

        return pRet;
    };
    */

    inline int32 getCount() const
    {
        return m_aPushers.Num() + m_aPushersSharedPtr.Num();
    };


    //Warn: returned value is still onwned by this class, never store it or make sharedPtr on it
    //returned value can't be modified, its pointer can't be modified neither 
    inline const FMyMJGamePusherBaseCpp* const peekAt(int32 idx) const
    {
        MY_VERIFY(idx < getCount());

        if (m_aPushers.Num() > 0) {
            return m_aPushers[idx];
        }

        return m_aPushersSharedPtr[idx].Get();
    };


protected:

    //Only one member could be not full at one time, m_aPushers.Num() > 0 tips it is in produce mode,  m_aPushersSharedPtr.Num() > 0 tips it is in consume mode
    TArray<FMyMJGamePusherBaseCpp*> m_aPushers; //We don't use shared pointer unless it reaches consumer, and this class "owns" it
                                                //Because TSharedPtr is not thread safe, we assume one thread only consume it, and when it is used, it will not transfer over thread any more

    TArray<TSharedPtr<FMyMJGamePusherBaseCpp>> m_aPushersSharedPtr;
};

USTRUCT(BlueprintType)
struct FMyMJGamePusherFillInActionChoicesCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherFillInActionChoicesCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherFillInActionChoices;

        m_iActionGroupId = 0;
        m_iIdxAttender = -1;
    };

    virtual ~FMyMJGamePusherFillInActionChoicesCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override;

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        int32 l = m_cActionChoices.getCount();
        str += FString::Printf(TEXT(" m_iActionGroupId: %d, m_iIdxAttender: %d, choices num: %d."), m_iActionGroupId, m_iIdxAttender, l);
        for (int32 i = 0; i < l; i++) {
            str += FString::Printf(TEXT(" idx %d: "), i) + m_cActionChoices.peekAt(i)->genDebugString();
        }

        return str;
    };


    void init(int32 iActionGroupId, int32 idxAttender)
    {
        m_iActionGroupId = iActionGroupId;
        m_iIdxAttender = idxAttender;
    };

    inline
    int32 getIdxAttender()
    {
        MY_VERIFY(m_iIdxAttender >= 0 && m_iIdxAttender < 4);
        return m_iIdxAttender;
    };

public:

    //Warn, this struct used FMyMJGamePusherPointersCpp, so use custom code for deep copy instead of operator =, so you need always modify the code when when add memebers
    UPROPERTY()
    FMyMJGamePusherPointersCpp m_cActionChoices;

    UPROPERTY()
    int32 m_iActionGroupId;

protected:

    UPROPERTY()
    int32 m_iIdxAttender;

};


USTRUCT(BlueprintType)
struct FMyMJGamePusherMadeChoiceNotifyCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherMadeChoiceNotifyCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherMadeChoiceNotify;
        m_iActionGroupId = 0;

        m_iSelection = 0;
        //m_iSelectionSub = 0;

        m_iIdxAttender = -1;
    };

    virtual ~FMyMJGamePusherMadeChoiceNotifyCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override;

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iActionGroupId: %d, m_iIdxAttender: %d, m_iSelection %d, m_aSubSelections.Num() %d."), m_iActionGroupId, m_iIdxAttender, m_iSelection, m_aSubSelections.Num());
        return str;
    };
     
    void init(int32 idxAttender, int32 iActionGroupId, int32 iSelection, TArray<int32> aSubSelections)
    {
        m_iIdxAttender = idxAttender;
        m_iActionGroupId = iActionGroupId;

        m_iSelection = iSelection;
        m_aSubSelections = aSubSelections;
        //m_iSelectionSub = iSelectionSub;
    };

    inline
    int32& getIdxAttenderRef()
    {
        return m_iIdxAttender;
    };

public:
    // < 0 means unknown, the system have made it mask
    UPROPERTY()
    int32 m_iSelection;

    UPROPERTY()
    TArray<int32> m_aSubSelections;

    UPROPERTY()
    int32 m_iActionGroupId;


protected:

    UPROPERTY()
    int32 m_iIdxAttender;
};


USTRUCT(BlueprintType)
struct FMyMJGamePusherCountUpdateCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherCountUpdateCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherCountUpdate;
        m_bActionGroupIncrease = false;
    };

    virtual ~FMyMJGamePusherCountUpdateCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGamePusherCountUpdateCpp *pRet = NULL;
        pRet = new FMyMJGamePusherCountUpdateCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_bActionGroupIncrease: %d."), m_bActionGroupIncrease);
        return str;
    };

    UPROPERTY()
    bool m_bActionGroupIncrease;

};

//Also put on cards, this pusher is just like a base state setting the game to
//When in UI, let's first apply data then animate in UI
USTRUCT(BlueprintType)
struct FMyMJGamePusherResetGameCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherResetGameCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherResetGame;

        m_iAttenderBehaviorRandomSelectMask = 0;
    };

    virtual ~FMyMJGamePusherResetGameCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override;


    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        return str;
    };

    //call this only when m_cGameCfg is set
    void init(FRandomStream *pRandomStream, FMyMJGameCfgCpp &cGameCfg, FMyMJGameRunDataCpp &cGameRunData, int32 iAttenderBehaviorRandomSelectMask);




    UPROPERTY()
    FMyMJGameCfgCpp m_cGameCfg;

    UPROPERTY()
    FMyMJGameRunDataCpp m_cGameRunData;

    UPROPERTY()
    TArray<int32> m_aShuffledValues;


    UPROPERTY()
    int32 m_iAttenderBehaviorRandomSelectMask;

};

#define MaskAttenderDataResetIdHandCardShowedOutLocalCS 0x01

USTRUCT(BlueprintType)
struct FMyMJGamePusherUpdateCardsCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherUpdateCardsCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherUpdateCards;
        m_iIdxAttender = -1;
    };

    virtual ~FMyMJGamePusherUpdateCardsCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGamePusherUpdateCardsCpp *pRet = NULL;
        pRet = new FMyMJGamePusherUpdateCardsCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iIdxAttender: %d, mask 0x%x"), m_iIdxAttender, m_iMaskAttenderDataReset);
        int32 l = m_aCardsTargetState.Num();
        for (int32 i = 0; i < l; i++) {
            str += m_aCardsTargetState[i].genDebugStr();
        }
        return str;
    };

    void initWithCardsTargetStateAlreadyInited(int32 idxAttender, int32 iMaskAttenderDataReset)
    {
        m_iIdxAttender = idxAttender;
        m_iMaskAttenderDataReset = iMaskAttenderDataReset;
    };

    //Possible -1, means update cards only
    UPROPERTY()
    int32 m_iIdxAttender;

    UPROPERTY()
    int32 m_iMaskAttenderDataReset;

    //possible empty when apply
    UPROPERTY()
    TArray<FMyMJCardCpp> m_aCardsTargetState;

};

USTRUCT(BlueprintType)
struct FMyMJGamePusherUpdateTingCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGamePusherUpdateTingCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::PusherUpdateTing;
        m_iIdxAttender = -1;
    };

    virtual ~FMyMJGamePusherUpdateTingCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        MY_VERIFY(m_iIdxAttender >= 0);
        if (eRoleType == MyMJGameRoleTypeCpp::SysKeeper || m_iIdxAttender == (uint8)eRoleType) {

            FMyMJGamePusherUpdateTingCpp *pRet = NULL;
            pRet = new FMyMJGamePusherUpdateTingCpp();

            *pRet = *this;

            return pRet;
        }
        else {
            return NULL;
        }

    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iIdxAttender: %d. %s"), m_iIdxAttender, *m_cTingGroup.genDebugString());
        return str;
    };

    void initWithTingGroupAlreadyInited(int32 idxAttender)
    {
        m_iIdxAttender = idxAttender;
    };

    UPROPERTY()
    int32 m_iIdxAttender;

    UPROPERTY()
    FMyMJHuScoreResultTingGroupCpp m_cTingGroup;

};


USTRUCT(BlueprintType)
struct FMyMJGameActionBaseCpp : public FMyMJGamePusherBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionBaseCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionBase;
        m_iPriority = 0;
        m_iIdxAttender = 0;
        m_iTimeLeft2AutoChoose = 0;
    };

    virtual ~FMyMJGameActionBaseCpp()
    {};


    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iIdxAttender: %d, m_iPriority %d, m_iTimeLeft2AutoChoose %" "lld" "."), m_iIdxAttender, m_iPriority, m_iTimeLeft2AutoChoose); //PRIu64 can't be used now since I didn't find a proper way to include the defines
        return str;
    };

    virtual int32 getRealCountOfSelection() const
    {
        return 1;
    };

    //return 0 if OK, transform this to target form, make sure this is stateless, means regargless how many times it is called, result is same
    virtual int32 makeSubSelection(TArray<int32> &subSelections)
    {
        MY_VERIFY(getRealCountOfSelection() > 1);
        return 0;
    };

    virtual int32 genRandomSubSelections(FRandomStream &RS, TArray<int32> &outSubSelections)
    {
        return 0;
    }

    //called in full mode collected, before enqueue and apply this give a chance to fill in data
    virtual void resolveActionResult(FMyMJGameAttenderCpp &attender)
    {
        return;
    }

    inline
    int32 getIdxAttender()
    {
        MY_VERIFY(m_iIdxAttender >= 0 && m_iIdxAttender < 4);
        return m_iIdxAttender;
    };

    inline
    int32 getPriority()
    {
        return m_iPriority;
    };

    inline
    int32& getIdxAttenderRef()
    {
        return m_iIdxAttender;
    };

    inline
    int64 getTimeLeft2AutoChoose()
    {
        return m_iTimeLeft2AutoChoose;
    };

    inline
    int64& getTimeLeft2AutoChooseRef()
    {
        return m_iTimeLeft2AutoChoose;
    };


protected:

    UPROPERTY()
    int32 m_iIdxAttender;

    UPROPERTY()
    int32 m_iPriority;

    //0 means instantly, < 0 means never
    UPROPERTY()
    int64 m_iTimeLeft2AutoChoose; //only used in full mode, not need to serialize, < 0 means not enabled
};

#define MyMJGameActionStateUpdateMaskNotResetHelperLastCardsGivenOutOrWeave 0x01

USTRUCT(BlueprintType)
struct FMyMJGameActionStateUpdateCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionStateUpdateCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionStateUpdate;
        m_iPriority = PriMyMJGameActionStateUpdate;

        m_eStateNext = MyMJGameStateCpp::Invalid; //Means not need to update
        m_iAttenderMaskNext = 0;
        m_bAllowSamePriAction = false;
        m_iIdxAttenderHavePriMax = 0;
        m_eReason = MyMJGameStateUpdateReasonCpp::Invalid;
        m_iMask = 0;
    };

    virtual ~FMyMJGameActionStateUpdateCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionStateUpdateCpp *pRet = NULL;
        pRet = new FMyMJGameActionStateUpdateCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        const UEnum* enumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("MyMJGamePusherTypeCpp"), true);
        FString enumStr;
        if (!enumPtr)
        {
            enumStr = FString("Invalid");
        }
        else {

            enumStr = enumPtr->GetEnumNameStringByValue((uint8)m_eType);
        }

        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_eStateNext: %s, m_iAttenderMaskNext: %s, m_eReason: %s."), *enumStr, *(UMyMJUtilsLibrary::formatMaskString(m_iAttenderMaskNext, 4)), *UMyMJUtilsLibrary::getStringFromEnum(TEXT("MyMJGameStateUpdateReasonCpp"), (uint8)m_eReason));

        return str;
    };

    UPROPERTY()
    MyMJGameStateCpp m_eStateNext;

    UPROPERTY()
    int32 m_iAttenderMaskNext;

    UPROPERTY()
    bool m_bAllowSamePriAction;
    
    UPROPERTY()
    int32 m_iIdxAttenderHavePriMax;

    UPROPERTY()
    MyMJGameStateUpdateReasonCpp m_eReason;

    UPROPERTY()
    int32 m_iMask;
};

#define MyMJGameActionNoActreserved0MaskPassPaoHu 0x01

USTRUCT(BlueprintType)
struct FMyMJGameActionNoActCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionNoActCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionNoAct;
        m_iPriority = PriMyMJGameActionNoAct;

        m_iReserved0 = 0;

    };

    virtual ~FMyMJGameActionNoActCpp()
    {

    };

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionNoActCpp *pRet = NULL;
        pRet = new FMyMJGameActionNoActCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {

        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iReserved0: %d."), m_iReserved0);
        return str;
    };

    inline
    void init(int32 idxAttender, int32 iReserved0)
    {
        m_iIdxAttender = idxAttender;
        m_iReserved0 = iReserved0;
    };

    UPROPERTY()
    int32 m_iReserved0;
};

UENUM(BlueprintType)
enum class MyMJGameActionThrowDicesSubTypeCpp : uint8
{
    Invalid = 0                             UMETA(DisplayName = "Invalid"),
    DistCardsAtStart = 10                   UMETA(DisplayName = "DistCardsAtStart"),
    GangYaoLocalCS = 50                     UMETA(DisplayName = "GangYaoLocalCS"),
};

USTRUCT(BlueprintType)
struct FMyMJGameActionThrowDicesCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionThrowDicesCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionThrowDices;
        m_iPriority = PriMyMJGameActionThrowDice;
        m_iDiceNumber0 = -1;
        m_iDiceNumber1 = -1;

        m_eSubType = MyMJGameActionThrowDicesSubTypeCpp::Invalid;

    };

    virtual ~FMyMJGameActionThrowDicesCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override;

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_iDiceNumber0: %d, m_iDiceNumber1: %d."), m_iDiceNumber0, m_iDiceNumber1);
        return str;
    };

    void init(MyMJGameActionThrowDicesSubTypeCpp eSubType, int32 idxAttender, FRandomStream *pRandomStream);

    void getDiceNumbers(int32 &outDiceNumber0, int32 &outDiceNumber1) const;

    MyMJGameActionThrowDicesSubTypeCpp getSubType() const;


protected:

    UPROPERTY()
    int32 m_iDiceNumber0;

    UPROPERTY()
    int32 m_iDiceNumber1;

    UPROPERTY()
    MyMJGameActionThrowDicesSubTypeCpp m_eSubType;

};


USTRUCT(BlueprintType)
struct FMyMJGameActionDistCardAtStartCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionDistCardAtStartCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionDistCardsAtStart;
        m_iPriority = PriMyMJGameActionDistCardAtStart;

    };

    virtual ~FMyMJGameActionDistCardAtStartCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override;

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_bLastCard: %d. cards: "), m_bLastCard);

        str += UMyMJUtilsLibrary::formatStrIdValuePairs(m_aIdValues);

        return str;
    };

    void init(int32 idxAttender, const TArray<FMyIdValuePair> &aIdValues, bool bLastCard)
    {
        m_iIdxAttender = idxAttender;
        m_aIdValues = aIdValues;
        m_bLastCard = bLastCard;
    };

    UPROPERTY()
    TArray<FMyIdValuePair> m_aIdValues;

    UPROPERTY()
    bool m_bLastCard;
};

UENUM(BlueprintType)
enum class MyMJGameCardTakenOrderCpp : uint8
{
    Invalid = 0                      UMETA(DisplayName = "Invalid"),
    Head = 1                         UMETA(DisplayName = "Head"),
    Tail = 2                         UMETA(DisplayName = "Tail"),
    NotFixed = 3                     UMETA(DisplayName = "NotFixed"),
};


USTRUCT(BlueprintType)
struct FMyMJGameActionTakeCardsCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionTakeCardsCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionTakeCards;
        m_iPriority = PriMyMJGameActionTakeCards;

        m_bIsGang = false;
        m_eTakenOrder = MyMJGameCardTakenOrderCpp::Invalid;

    };

    virtual ~FMyMJGameActionTakeCardsCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionTakeCardsCpp *pRet = new FMyMJGameActionTakeCardsCpp();
        *pRet = *this;

        if ((uint8)eRoleType != m_iIdxAttender) {
            UMyMJUtilsLibrary::resetCardValueInIdValuePairs(pRet->m_aIdValuePairs);
        }

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_bIsGang: %d, m_eTakenOrder %d."), m_bIsGang, (uint8)m_eTakenOrder);
        str += UMyMJUtilsLibrary::formatStrIdValuePairs(m_aIdValuePairs);

        return str;
    };


    void initWithIdValuePairsInited(int32 idxAttender, bool bIsGang, MyMJGameCardTakenOrderCpp eTakenOrder)
    {
        m_iIdxAttender = idxAttender;
        m_bIsGang = bIsGang;
        m_eTakenOrder = eTakenOrder;
    };


    UPROPERTY()
    TArray<FMyIdValuePair> m_aIdValuePairs;

    UPROPERTY()
    bool m_bIsGang;

    UPROPERTY()
    MyMJGameCardTakenOrderCpp m_eTakenOrder;

};

USTRUCT(BlueprintType)
struct FMyMJGameActionGiveOutCardsCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionGiveOutCardsCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionGiveOutCards;
        m_iPriority = PriMyMJGameActionGiveOutCards;

        m_bRestrict2SelectCardsJustTaken = false;
        m_bIsGang = false;

    };

    virtual ~FMyMJGameActionGiveOutCardsCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionGiveOutCardsCpp *pRet = new FMyMJGameActionGiveOutCardsCpp();
        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_bRestrict2SelectCardsJustTaken %d, real count: %d. selected: %s."), m_bRestrict2SelectCardsJustTaken, getRealCountOfSelection(), *UMyMJUtilsLibrary::formatStrIdValuePairs(m_aIdValuePairsSelected));

        return str;
    };

    virtual int32 getRealCountOfSelection() const override
    {
        if (m_bRestrict2SelectCardsJustTaken) {
            return 1;
        }
        else {

            int32 count0 = m_aOptionIdsHandCard.Num();
            int32 count1 = m_aOptionIdsJustTaken.Num();
            int32 countAll = count0 + count1;
            MY_VERIFY(countAll > 0);
            return countAll;
        }
    };

    //subSelection here contains card Id
    virtual int32 makeSubSelection(TArray<int32> &subSelections) override;

    //subSelection here contains card Id
    virtual int32 genRandomSubSelections(FRandomStream &RS, TArray<int32> &outSubSelections) override;

    virtual void resolveActionResult(FMyMJGameAttenderCpp &attender) override;

    void init(int32 idxAttender, TArray<int32> &aOptionIdsHandCard, TArray<int32> &aOptionIdsJustTaken, bool bRestrict2SelectCardsJustTaken, bool bIsGang)
    {
        m_iIdxAttender = idxAttender;
        m_aOptionIdsHandCard = aOptionIdsHandCard;
        m_aOptionIdsJustTaken = aOptionIdsJustTaken;

        m_bRestrict2SelectCardsJustTaken = bRestrict2SelectCardsJustTaken;

        if (m_bRestrict2SelectCardsJustTaken) {
            FMyIdValuePair::helperIds2IdValuePairs(m_aOptionIdsJustTaken, m_aIdValuePairsSelected);
        }

        m_bIsGang = bIsGang;
    };

    UPROPERTY()
    TArray<int32> m_aOptionIdsHandCard;

    UPROPERTY()
    TArray<int32> m_aOptionIdsJustTaken;

    UPROPERTY()
    TArray<FMyIdValuePair> m_aIdValuePairsSelected;

    //if false, choose one card, if true, move out all cads just taken
    UPROPERTY()
    bool m_bRestrict2SelectCardsJustTaken;

    UPROPERTY()
    bool m_bIsGang;

};


USTRUCT(BlueprintType)
struct FMyMJGameActionWeaveCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionWeaveCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionWeave;
        m_iPriority = 0;

        m_eTargetFlipState = MyMJCardFlipStateCpp::Up;
    };

    virtual ~FMyMJGameActionWeaveCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionWeaveCpp *pRet = new FMyMJGameActionWeaveCpp();
        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += FString::Printf(TEXT(" m_eTargetFlipState: %s."), *UMyMJUtilsLibrary::getStringFromEnum(TEXT("MyMJCardFlipStateCpp"), (uint8)m_eTargetFlipState));
        str += m_cWeave.genDebugString();

        return str;
    };

    void initWithWeaveAlreadyInited(int32 idxAttender, MyMJCardFlipStateCpp eTargetFlipState)
    {
        m_iIdxAttender = idxAttender;
        m_eTargetFlipState = eTargetFlipState;
        MyMJWeaveTypeCpp eType = m_cWeave.getType();
        if (eType == MyMJWeaveTypeCpp::ShunZiMing) {
            m_iPriority = PriMyMJGameActionWeaveShunZiMing;
        }
        else if (eType == MyMJWeaveTypeCpp::KeZiMing) {
            m_iPriority = PriMyMJGameActionWeaveKeZiMing;
        }
        else if (eType == MyMJWeaveTypeCpp::GangMing) {
            m_iPriority = PriMyMJGameActionWeaveGangMing;
        }
        else if (eType == MyMJWeaveTypeCpp::GangAn) {
            m_iPriority = PriMyMJGameActionWeaveGangAn;
        }
        else {
            MY_VERIFY(false);
        }
    };

    //it is possible ingame hu not ending the game, such as, one attender exit as observer and other continue
    UPROPERTY()
    FMyMJWeaveCpp m_cWeave;

    //In some MJ rule, anGang need to be hide
    UPROPERTY()
    MyMJCardFlipStateCpp m_eTargetFlipState;

};



USTRUCT(BlueprintType)
struct FMyMJGameActionHuCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionHuCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionHu;
        m_iPriority = PriMyMJGameActionHu;
        m_bEndGame = true;
    };

    virtual ~FMyMJGameActionHuCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionHuCpp *pRet = new FMyMJGameActionHuCpp();
        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += m_cHuScoreResultFinalGroup.genDebugString();

        return str;
    };

    virtual void resolveActionResult(FMyMJGameAttenderCpp &attender) override;

    void init(int32 idxAttender, bool bEndGame, FMyMJHuScoreResultFinalGroupCpp &finalGroup)
    {
        m_iIdxAttender = idxAttender;
        m_bEndGame = bEndGame;
        m_cHuScoreResultFinalGroup = finalGroup;

    };

    void initWithFinalGroupAlreadyInited(int32 idxAttender, bool bEndGame)
    {
        m_iIdxAttender = idxAttender;
        m_bEndGame = bEndGame;

        MY_VERIFY(m_cHuScoreResultFinalGroup.m_iIdxAttenderWin >= 0);

    };

    //it is possible ingame hu not ending the game, such as, one attender exit as observer and other continue
    UPROPERTY()
    bool m_bEndGame;

    UPROPERTY()
    FMyMJHuScoreResultFinalGroupCpp m_cHuScoreResultFinalGroup;

    UPROPERTY()
    TArray<FMyIdValuePair> m_aRevealingCards;
};


USTRUCT(BlueprintType)
struct FMyMJGameActionHuBornLocalCSCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionHuBornLocalCSCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionHuBornLocalCS;
        m_iPriority = PriMyMJGameActionHuBornLocalCS;
    };

    virtual ~FMyMJGameActionHuBornLocalCSCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionHuBornLocalCSCpp *pRet = NULL;
        pRet = new FMyMJGameActionHuBornLocalCSCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += TEXT(" cards: ");
        str += UMyMJUtilsLibrary::formatStrIdValuePairs(m_aShowOutIdValues);

        int32 l = m_aHuScoreResultItems.Num();
        str += FString::Printf(TEXT(" huScoreItem.Num %d: "), l);
        for (int32 i = 0; i < l; i++) {
            const FMyMJHuScoreResultItemCpp *pItem = &(m_aHuScoreResultItems[i]);
            str += FString::Printf(TEXT("type %s, scorePerAttender %d, count %d"), *UMyMJUtilsLibrary::getStringFromEnum(TEXT("MyMJHuScoreTypeCpp"), (uint8)pItem->m_eType), pItem->m_iScorePerAttender, pItem->m_iCount);
        }

        return str;
    };

    inline
    void init(int32 idxAttender, const TArray<FMyMJHuScoreResultItemCpp> &aHuScoreResultItems, const TArray<FMyIdValuePair> &aShowOutIdValues)
    {
        m_iIdxAttender = idxAttender;
        m_aHuScoreResultItems = aHuScoreResultItems;
        m_aShowOutIdValues = aShowOutIdValues;

    };

    UPROPERTY()
    TArray<FMyMJHuScoreResultItemCpp> m_aHuScoreResultItems;

    UPROPERTY()
    TArray<FMyIdValuePair> m_aShowOutIdValues;

};

USTRUCT(BlueprintType)
struct FMyMJGameActionZhaNiaoLocalCSCpp : public FMyMJGameActionBaseCpp
{
    GENERATED_USTRUCT_BODY()

public:
    FMyMJGameActionZhaNiaoLocalCSCpp() : Super()
    {
        m_eType = MyMJGamePusherTypeCpp::ActionZhaNiaoLocalCS;
        m_iPriority = PriMyMJGameActionZhaNiaoLocalCS;
    };

    virtual ~FMyMJGameActionZhaNiaoLocalCSCpp()
    {};

    virtual FMyMJGamePusherBaseCpp* cloneDeep() const override
    {
        FMyMJGameActionZhaNiaoLocalCSCpp *pRet = NULL;
        pRet = new FMyMJGameActionZhaNiaoLocalCSCpp();

        *pRet = *this;

        return pRet;
    };

    virtual FString genDebugString() const override
    {
        FString str = Super::genDebugString();
        str += TEXT(" cards: ");
        str += UMyMJUtilsLibrary::formatStrIdValuePairs(m_aPickedIdValues);

        return str;
    };

    inline
    void initWithPickedIdValuesInited(int32 idxAttender)
    {
        m_iIdxAttender = idxAttender;
    };


    UPROPERTY()
    TArray<FMyIdValuePair> m_aPickedIdValues;

};


UCLASS()
class MYONLINECARDGAME_API AMyTestParentClass0 : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY()
        int32 m_iTest;

};

UCLASS()
class MYONLINECARDGAME_API AMyTestChildClass0 : public AMyTestParentClass0
{
    GENERATED_BODY()

public:
    UPROPERTY()
        int32 m_iTestChild;

};



UCLASS()
class UMyMJGameUtilsLibrary :
    public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
        //GENERATED_UCLASS_BODY()


        //UFUNCTION(BlueprintCallable, Category = "Analytics")
        //static bool StartSession();

public:

    /* only return basic type, not ext */
    UFUNCTION(BlueprintCallable, Category = "UMyMJGameUtilsLibrary")
    static void testArrayPointerSerialize(AMyTestParentClass0 *pInParent, AMyTestChildClass0 *pInChild, AMyTestParentClass0 *pOutParent, int32 param);


    UPROPERTY()
    TArray<FMyMJGamePusherBaseCpp> m_aPushers0;
};


